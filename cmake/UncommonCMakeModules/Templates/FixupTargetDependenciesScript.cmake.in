# Mark J. Olah (mjo@cs.unm DOT edu)
# Copyright 2014-2017
# Licensed under the Apache License, Version 2.0
# https://www.apache.org/licenses/LICENSE-2.0
# See: LICENCE file
#
# FixupTargetDependenciesScript.cmake.in -
# This is a template file for use by the fixup_dependencies() function.
# This scripts is configured and to be executed at install-time to copy necessary dependencies from the system and other
# sources into the local install-tree of one or more targets
#

cmake_minimum_required(VERSION 3.7)

function(transform_filename_component_list list_name component)
    list(LENGTH ${list_name} ndirs)
    math(EXPR niter "${ndirs} - 1")
    set(_new_list)
    if(niter GREATER_EQUAL 0)
        foreach(idx RANGE ${niter})
            list(GET ${list_name} ${idx} _dir)
            get_filename_component(_c ${_dir} ${component})
            list(APPEND _new_list ${_c})
        endforeach()
    endif()
    set(${list_name} ${_new_list} PARENT_SCOPE)
endfunction()


set(target @FIXUP_TARGET@)
set(project_name @PROJECT_NAME@)
set(install_prefix ${CMAKE_INSTALL_PREFIX}) #this should be set at install time

set(target_file_name $<TARGET_FILE_NAME:@FIXUP_TARGET@>)
set(target_build_dir $<TARGET_FILE_DIR:@FIXUP_TARGET@>)
set(msg_hdr "[fixup_dependencies:install_phase] [@FIXUP_TARGET@]")
message(STATUS "${msg_hdr} target_file:${target_file_name}")
message(STATUS "${msg_hdr} target_build_dir:${target_build_dir}")
#relative directory path from ${CMAKE_INSTALL_PREFIX} that target will be installed to
set(target_destination @FIXUP_TARGET_DESTINATION@)
if(NOT target_destination)
    #try to find installed file
    find_file(${target}_install_file ${target_file_name} PATHS ${install_prefix} PATH_SUFFIXES lib lib/${project_name} bin bin/${project_name} NO_DEFAULT_PATH)
    if(${${target}_install_file} STREQUAL "${target}_install_file-NOTFOUND")
        message(FATAL_ERROR "Could not find installed location for target fixup file: ${target_file_name} under install dir: ${install_prefix}")
    endif()
    message(STATUS "${msg_hdr} Fixing up target_install_file:${${target}_install_file}")
    get_filename_component(target_install_dir ${${target}_install_file} DIRECTORY)
    file(RELATIVE_PATH target_destination ${install_prefix} "${target_install_dir}")
endif()
set(target_install_dir ${install_prefix}/${target_destination})
set(target_install_file ${target_install_dir}/${target_file_name})
get_filename_component(lib_dest ${target_install_dir}/@FIXUP_COPY_DESTINATION@ ABSOLUTE) #Destination for libraries to copy in
message(STATUS "${msg_hdr} install_prefix: ${install_prefix} target_destination: ${target_destination}")
message(STATUS "${msg_hdr} target_install_dir: ${target_install_dir}")
message(STATUS "${msg_hdr} target_install_file: ${target_install_file}")
message(STATUS "${msg_hdr} fixup lib copy deststination: ${lib_dest}")


#Get Rpaths as aboslute paths
include(BundleUtilities)
unset(rpaths)
get_item_rpaths(${target_install_file} rpaths)
transform_filename_component_list(rpaths REALPATH)

set(provided_lib_dirs @FIXUP_PROVIDED_LIB_DIRS@)
transform_filename_component_list(provided_lib_dirs REALPATH)
set(provided_libs @FIXUP_PROVIDED_LIBS@)

set(crosscompiling @CMAKE_CROSSCOMPILING@)
set(toolchain_file @CMAKE_TOOLCHAIN_FILE@)
set(target_os @FIXUP_TARGET_OS@)

set(staging_prefix @CMAKE_STAGING_PREFIX@)
if(staging_prefix)
    get_filename_component(staging_prefix ${staging_prefix} REALPATH)
endif()

set(find_root_path @CMAKE_FIND_ROOT_PATH@)
if(find_root_path)
    transform_filename_component_list(find_root_path REALPATH)
endif()

set(sysroot @CMAKE_SYSROOT@)
if(sysroot)
    get_filename_component(sysroot ${sysroot} REALPATH)
endif()

set(search_lib_dirs @FIXUP_SEARCH_LIB_DIRS@)
if(search_lib_dirs)
    transform_filename_component_list(search_lib_dirs REALPATH)
endif()

set(gp_exclude_system_libs 1)
if(target_os STREQUAL "UNIX")
    set(gp_tool "ldd")
    set(gp_recurse 1)
elseif(target_os STREQUAL "WIN32")
    set(gp_tool "objdump")
    set(gp_recurse 0)
    list(APPEND provided_libs kernel32 user32 msvcrt advapi32)
endif()

message(STATUS "${msg_hdr} target rpaths: ${rpaths}")
message(STATUS "${msg_hdr} provided_lib_dirs: ${provided_lib_dirs}")
message(STATUS "${msg_hdr} provided_libs: ${provided_libs}")
message(STATUS "${msg_hdr} search_lib_dirs: ${search_lib_dirs}")
message(STATUS "${msg_hdr} find_root_path: ${find_root_path}")
# message(STATUS "${msg_hdr} crosscompiling: ${crosscompiling}")
# message(STATUS "${msg_hdr} target_os: ${target_os}")
# message(STATUS "${msg_hdr} toolchain_file: ${toolchain_file}")
# message(STATUS "${msg_hdr} staging_prefix: ${staging_prefix}")
# message(STATUS "${msg_hdr} sysroot: ${sysroot}")

include(GetPrerequisites)
set(search_dirs ${provided_lib_dirs} ${lib_dest} ${rpaths} ${install_prefix} ${staging_prefix} ${find_root_path} ${sysroot} ${search_lib_dirs})
# message(STATUS "${msg_hdr} search_dirs: ${search_dirs}")

function(gp_resolve_item_override context item exepath dirs resolved_item_var resolved_var)
    if(NOT ${resolved_var} AND @FIXUP_TARGET_OS@ STREQUAL WIN32)
        string(TOLOWER ${item} Litem)
        get_filename_component(_lib ${Litem} NAME_WE)
        if(_lib IN_LIST provided_libs)
            #message(STATUS "Auto-resolving system lib: ${item}")
            set(${resolved_item_var} /system/${item} PARENT_SCOPE)
            set(${resolved_var} 1 PARENT_SCOPE)
        endif()
        find_file(fitem ${item} PATHS ${search_dirs} PATH_SUFFIXES bin lib NO_DEFAULT_PATH)
        if(fitem)
            #message(STATUS "FOUND Resolving as: ${fitem}")
            set(${resolved_item_var} ${fitem} PARENT_SCOPE)
            set(${resolved_var} 1 PARENT_SCOPE)
            unset(fitem CACHE)
        endif()
    endif()
endfunction()

function(gp_resolved_file_type_override resolved_file type)
    if(provided_libs)
        get_filename_component(file_dir ${resolved_file} DIRECTORY)
        get_filename_component(file_name ${resolved_file} NAME)
        if(${target_os} STREQUAL "WIN32")
            string(TOLOWER ${file_name} file_name)
        endif()
        if(${file_name} IN_LIST provided_libs)
            message(STATUS "  *** Resolving type of: ${file_name} in dir: ${file_dir} as provided system library.")
            set(${type} system PARENT_SCOPE)
        endif()
    endif()
endfunction()

unset(deps)
get_prerequisites(${target_install_file} deps ${gp_exclude_system_libs} ${gp_recurse} "" "${search_dirs}")

#message(STATUS "Target: ${target_install_file} Deps: ${deps}")

foreach(dep IN LISTS deps)
    get_filename_component(dep_name ${dep} NAME)
    get_filename_component(dep_base_name ${dep} NAME_WE)
    get_filename_component(dep_dir ${dep} DIRECTORY)
    if(dep_dir AND NOT IS_ABSOLUTE dep_dir)
        get_filename_component(dep_dir ${dep_dir} ABSOLUTE)
    endif()
    if(NOT dep_dir)
        #PROVIDED_LIBS - Do not copy
        if(provided_libs)
            if(target_os STREQUAL WIN32)
                string(TOLOWER ${dep_base_name} _lib)
                if(${_lib} IN_LIST provided_libs)
                    unset(_lib)
                    message(STATUS "  *** ${dep_name}: Vendor provided library.")
                    continue()
                endif()
            else()
                if(${dep_base_name} IN_LIST provided_libs)
                    message(STATUS "  *** ${dep_name}: Vendor provided library.")
                    continue()
                endif()
            endif()
        endif()

        #Otherwise try to find file
        if(target_os STREQUAL UNIX)
            find_file(fitem ${dep} PATHS ${search_dirs} PATH_SUFFIXES lib usr/lib NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        elseif(target_os STREQUAL WIN32)
            find_file(fitem ${dep} PATHS ${search_dirs} PATH_SUFFIXES bin lib usr/bin usr/lib NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        endif()
        if(NOT fitem)
            message(FATAL_ERROR "Could not find dependency ${dep} in dirs:${search_dirs}")
        endif()
        set(dep ${fitem})
        unset(fitem CACHE)
        unset(fitem)
        get_filename_component(dep_dir ${dep} DIRECTORY)
    endif()


    #PROVIDED_LIBS_DIRS - Do not copy
    if(provided_lib_dirs AND ${dep_dir} IN_LIST provided_lib_dirs)
        message(STATUS "  *** ${dep_name}: In vendor provided lib dir: ${dep_dir}")
        continue()
    endif()
    #COPY_DESTINATION  - Do not copy
    if(dep_dir STREQUAL lib_dest)
        message(STATUS "  --- ${dep_name}: Already exists at lib copy dest: ${lib_dest}")
        continue()
    endif()
    #RPATHS - Do not copy [UNIX only]
    if(target_os STREQUAL UNIX AND rpaths AND dep_dir IN_LIST rpaths)
        message(STATUS "  --- ${dep_name}: Already exists on rpath at: ${dep_dir}")
        continue()
    endif()
    #install_prefix - Copy for WIN32
    if(dep_dir MATCHES "^${install_prefix}")
        if(target_os STREQUAL "UNIX")
            message(STATUS "  --- ${dep_name}: Exists under install_prefix at: ${dep_dir}")
        elseif(${target_os} STREQUAL "WIN32")
            message(STATUS "  +++ ${dep_name}: Exists under install_prefix at: ${dep_dir}. But not present in copy dest.")
            execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep} ${lib_dest})
            message(STATUS "  +++ Copying:  ${dep} --> ${lib_dest}")
        endif()
        continue()
    endif()
    #staging_prefix - Copy for WIN32
    if(staging_prefix AND dep_dir MATCHES "^${staging_prefix}")
        if(target_os STREQUAL "UNIX")
            message(STATUS "  --- ${dep_name}: Exists under staging_prefix at: ${dep_dir}")
        elseif(target_os STREQUAL "WIN32")
            message(STATUS "  +++ ${dep_name}: Exists under staging_prefix at: ${dep_dir}. But not present in copy dest.")
            execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep} ${lib_dest})
            message(STATUS "  +++ Copying:  ${dep} --> ${lib_dest}")
        endif()
        continue()
    endif()
    #sysroot - copy
    if(sysroot AND dep_dir MATCHES "^${sysroot}")
        message(STATUS "  +++ ${dep_name}: Exists under sysroot at: ${dep_dir}")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep} ${lib_dest})
        message(STATUS "  +++ Copying:  ${dep} --> ${lib_dest}")
        continue()
    endif()

    #find_root_path - copy
    if(find_root_path)
        set(_found)
        foreach(root IN LISTS find_root_path)
            if(${dep_dir} MATCHES "^${root}")
                message(STATUS "  +++ ${dep_name}: Exists under find_root at: ${dep_dir}")
                execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep} ${lib_dest})
                message(STATUS "  +++ Copying:  ${dep} --> ${lib_dest}")
                set(_found 1)
                break()
            endif()
        endforeach()
        if(_found)
            unset(_found)
            continue()
        endif()
    endif()

    #search_lib_dirs - copy
    if(search_lib_dirs)
        set(_found)
        foreach(root IN LISTS search_lib_dirs)
            if(${dep_dir} MATCHES "^${root}")
                message(STATUS "  +++ ${dep_name}: Exists under search_lib_dirs at: ${dep_dir}")
                execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep} ${lib_dest})
                message(STATUS "  +++ Copying:  ${dep} --> ${lib_dest}")
                set(_found 1)
                break()
            endif()
        endforeach()
        if(_found)
            unset(_found)
            continue()
        endif()
    endif()

    #
    if(target_os STREQUAL UNIX)
        set(system_dirs /lib /slib /usr/lib /usr/slib)
        set(_found)
        foreach(root IN LISTS system_dirs)
            if(${dep_dir} MATCHES "^${root}")
                if(crosscompiling)
                    message(STATUS "  ??? ${dep_name}: Exists under build system dirs at: ${dep_dir}.  Probably this is not correct.  Possible find_file error in paths.  ")
                else()
                    message(STATUS "  --- ${dep_name}: Exists under system dir at: ${dep_dir}.")
                endif()
                set(_found 1)
                break()
            endif()
        endforeach()
        if(_found)
            unset(_found)
            continue()
        endif()
    endif()
    message(STATUS " ??? ${dep_name}: How did we find this at : ${dep_dir}")
endforeach()

