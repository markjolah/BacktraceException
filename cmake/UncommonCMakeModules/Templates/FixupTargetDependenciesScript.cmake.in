# Mark J. Olah (mjo@cs.unm DOT edu)
# Copyright 2014-2017
# Licensed under the Apache License, Version 2.0
# https://www.apache.org/licenses/LICENSE-2.0
# See: LICENCE file
#
# FixupTargetDependenciesScript.cmake.in -
# This is a template file for use by the fixup_dependencies() function.
# This scripts is configured and to be executed at install-time to copy necessary dependencies from the system and other
# sources into the local install-tree of one or more targets
#
cmake_minimum_required(VERSION 3.7)
# if(@CMAKE_CROSSCOMPILING@)
#     include(@CMAKE_TOOLCHAIN_FILE@)
# endif()

set(project_name @PROJECT_NAME@)
set(fixup_target @FIXUP_TARGET@)
if(NOT TARGET fixup_target)
    message(FATAL_ERROR "[fixup_dependencies:install_phase] Got a fixup-target: ${fixup_target} Which is not a target.")
endif()

set(install_prefix ${CMAKE_INSTALL_PREFIX}) #this should be set at install time
get_filename_component(install_prefix ${install_prefix} REALPATH) #Ensure we have a cannonical path to install at

set(target_file_name $<TARGET_FILE_NAME:${fixup_target}>)
set(target_build_dir $<TARGET_FILE_DIR:${fixup_target}>)
set(msg_hdr "[fixup_dependencies:install_phase] [${fixup_target}]")
message(STATUS "${msg_hdr}: file name:${target_file_name}")
message(STATUS "${msg_hdr}: build dir:${target_build_dir}")

function(transform_filename_component_list list_name component)
    list(LENGTH ${list_name} ndirs)
    math(EXPR niter "${ndirs} - 1")
    set(_new_list)
    if(niter GREATER_EQUAL 0)
        foreach(idx RANGE ${niter})
            list(GET ${list_name} ${idx} _dir)
            get_filename_component(_c ${_dir} ${component})
            list(APPEND _new_list ${_c})
        endforeach()
    endif()
    set(${list_name} ${_new_list} PARENT_SCOPE)
endfunction()


function(read_rpath out_var target tag)
    get_filename_component(_target_dir ${target} DIRECTORY)
    set(${out_var} False PARENT_SCOPE) #default to false
    if(NOT IS_ABSOLUTE target OR NOT IS_DIRECTORY _target_dir)
        message(WARNING "${msg_hdr} target: ${target} not absolute or dir:${_target_dir} not found.")
        return()
    endif()
    if(target_os STREQUAL WIN32)
        message(WARNING "${msg_hdr} runpath does not exist on WIN32.")
        return()
    endif()
    execute_process(COMMAND "readelf -d ${target}" RESULT_VARIABLE _ret OUTPUT_VARIABLE _out ERROR_VARIABLE _err)
    if(NOT _out EQUAL 0)
        message(WARNING "${msg_hdr} Could not readelf on ${target}. ret:${_ret} out:${_out} err:${_err}")
        return()
    endif()
    message(STATUS "${msg_hdr} readelf got: out:${_out}")
    if(_out MATCHES "\(${tag}\)[ \t]+[A-Za-z ]+:[ \t]*\[([^\]]+)\][ \t\r]*\n")
        set(_val ${CMAKE_MATCH_1})
        string(REGEX_REPLACE "\$\(?ORIGIN\)?" ${_target_dir} _val "${_val}")
        set(${out_var} ${_val} PARENT_SCOPE)
    endif()
endfunction()

function(read_ld_libraray_path path_var)
    set(path $ENV{LD_LIBRARY_PATH})
    set(${path_var} ${path} PARENT_SCOPE)
endfunction()


function(read_direct_dependencies out_var target)
    get_filename_component(_target_dir ${target} DIRECTORY)
    set(${out_var} False PARENT_SCOPE) #default to false
    if(NOT IS_ABSOLUTE target OR NOT IS_DIRECTORY _target_dir)
        message(WARNING "${msg_hdr} target: ${target} not absolute or dir:${_target_dir} not found.")
        return()
    endif()
    if(target_os STREQUAL UNIX)
        execute_process(COMMAND "readelf -d ${target}" RESULT_VARIABLE _ret OUTPUT_VARIABLE _out ERROR_VARIABLE _err)
        if(NOT _out EQUAL 0)
            message(WARNING "${msg_hdr} Could not readelf on ${target}. ret:${_ret} out:${_out} err:${_err}")
            return()
        endif()
        message(STATUS "${msg_hdr} read_direct_dependencies got: out:${_out}")
        string(REPLACE "\n" ";" _out "${_out}")
        set(_needed)
        foreach(_line IN LISTS _out)
            if(_line MATCHES "\(NEEDED\)[ \t]+[A-Za-z ]+:[ \t]*\[([^\]]+)\][ \t\r]*\n")
                list(APPEND _needed ${CMAKE_MATCH_1})
            endif()
        endforeach()
        set(${out_var} "${_needed}" PARENT_SCOPE)
    elseif(target_os STREQUAL WIN32)
        execute_process(COMMAND "objdump -p ${target} | grep -i 'DLL Name'" RESULT_VARIABLE _ret OUTPUT_VARIABLE _out ERROR_VARIABLE _err)
        if(NOT _out EQUAL 0)
            message(WARNING "${msg_hdr} Could not readelf on ${target}. ret:${_ret} out:${_out} err:${_err}")
            return()
        endif()
        message(STATUS "${msg_hdr} read_direct_dependencies got: out:${_out}")
        string(REPLACE "\n" ";" _out "${_out}")
        set(_needed)
        foreach(_line IN LISTS _out)
            if(_line MATCHES "DLL Name:[ \t]+([A-Za-z0-9\._+-]+\.[dD][lL][lL])[ \t\r]+")
                list(APPEND _needed ${CMAKE_MATCH_1})
            endif()
        endforeach()
        set(${out_var} "${_needed}" PARENT_SCOPE)
    endif()
endfunction()


#Find target_destination: the relative directory path from ${CMAKE_INSTALL_PREFIX} that target will be installed to
set(target_destination @FIXUP_TARGET_DESTINATION@)
if(NOT target_destination)
    if(IS_ABSOLUTE fixup_target)
        if(
    #try to find installed file
    find_file(_file ${target_file_name} PATHS ${install_prefix} PATH_SUFFIXES lib lib/${project_name} bin bin/${project_name} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
    if(_file)
        message(FATAL_ERROR "Could not find installed location for target fixup file: ${target_file_name} under install dir: ${install_prefix}")
    endif()
    message(STATUS "${msg_hdr} Fixing up target_install_file:${${target}_install_file}")
    get_filename_component(target_install_dir ${${target}_install_file} DIRECTORY)
    file(RELATIVE_PATH target_destination ${install_prefix} "${target_install_dir}")
endif()

set(target_install_dir ${install_prefix}/${target_destination})
set(target_install_file ${target_install_dir}/${target_file_name})
get_filename_component(lib_copy_dest ${target_install_dir}/@FIXUP_COPY_DESTINATION@ ABSOLUTE) #Destination for libraries to copy in

message(STATUS "${msg_hdr} install_prefix: ${install_prefix} target_destination: ${target_destination}")
message(STATUS "${msg_hdr} target_install_dir: ${target_install_dir}")
message(STATUS "${msg_hdr} target_install_file: ${target_install_file}")
message(STATUS "${msg_hdr} lib_copy_dest: ${lib_copy_dest}")



set(provided_lib_dirs @FIXUP_PROVIDED_LIB_DIRS@)
transform_filename_component_list(provided_lib_dirs REALPATH)
set(provided_libs @FIXUP_PROVIDED_LIBS@)

set(crosscompiling @CMAKE_CROSSCOMPILING@)
set(toolchain_file @CMAKE_TOOLCHAIN_FILE@)
set(target_os @FIXUP_TARGET_OS@)

set(staging_prefix @CMAKE_STAGING_PREFIX@)
if(staging_prefix)
    get_filename_component(staging_prefix ${staging_prefix} REALPATH)
endif()

set(find_root_path @CMAKE_FIND_ROOT_PATH@)
if(find_root_path)
    transform_filename_component_list(find_root_path REALPATH)
endif()

set(sysroot @CMAKE_SYSROOT@)
if(sysroot)
    get_filename_component(sysroot ${sysroot} REALPATH)
endif()

set(search_lib_dirs @FIXUP_SEARCH_LIB_DIRS@)
if(search_lib_dirs)
    transform_filename_component_list(search_lib_dirs REALPATH)
endif()

#default_library_search_suffixs - generally matches the CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES
if(target_os STREQUAL "UNIX")
    set(_suffixs @CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES@) #dirs of libraries provided by host system
    set(default_library_search_suffixs)
    foreach(sdir IN LISTS _suffixs)
        if(sdir MATCHES "^/(.*)")
            list(APPEND default_library_search_suffixs ${CMAKE_MATCH_1})
        else()
            list(APPEND default_library_search_suffixs ${sdir})
        endif()
    endforeach()
    unset(_suffixs)
elseif(target_os STREQUAL "WIN32")
    set(_suffixs @CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES@) #dirs of libraries provided by host system
    set(default_library_search_suffixs bin usr/bin)
    foreach(sdir IN LISTS _suffixs)
        foreach(pre IN LISTS CMAKE_FIND_ROOT_PATH)
            if(sdir MATCHES "^${pre}/(.*)")
                list(APPEND default_library_search_suffixs ${CMAKE_MATCH_1})
                continue()
            endif()
        endforeach()
        if(sdir MATCHES "^$/(.*)")
            list(APPEND default_library_search_suffixs ${CMAKE_MATCH_1})
        else()
            list(APPEND default_library_search_suffixs ${sdir})
        endif()
    endforeach()
    unset(_suffixs)
endif()

#Provided system libraries that should not be copied or recursed on.
if(target_os STREQUAL "UNIX")
    #libc and ld-linux-x86-64 loader must match versions exactly with system loader since
    #the loader location is hard-coded as an absolute path, it cannot be made relocatable without using system
    #loader which implied also using system libc.
    list(APPEND provided_libs libc ld-linux-x86-64 libdl libpthread libcrypt librt libm)
    #list(APPEND provided_libs libpam)
elseif(target_os STREQUAL "WIN32")
    list(APPEND provided_libs kernel32 user32 msvcrt advapi32 ws2_32 msvcp120 msvcr120 msvcp120 dbghelp oleaut32 ole32 psapi powrprof)
endif()

message(STATUS "${msg_hdr} target rpaths: ${rpaths}")
message(STATUS "${msg_hdr} provided_lib_dirs: ${provided_lib_dirs}")
message(STATUS "${msg_hdr} provided_libs: ${provided_libs}")
message(STATUS "${msg_hdr} search_lib_dirs: ${search_lib_dirs}")
message(STATUS "${msg_hdr} find_root_path: ${find_root_path}")
message(STATUS "${msg_hdr} default_library_search_suffixs: ${default_library_search_suffixs}")
message(STATUS "${msg_hdr} crosscompiling: ${crosscompiling}")
message(STATUS "${msg_hdr} target_os: ${target_os}")


function(fixup_target target)
    if(target STREQUAL fixup_target
    set(direct_target
endfunction()




#GetPrerequisites use with overrides for gp_resolve_item_override and gp_resolved_file_type_override
set(CMAKE_MODULE_PATH  ${CMAKE_CURRENT_LIST_DIR}/../../cmake/UncommonCMakeModules ${CMAKE_MODULE_PATH})
include(GetPrerequisites)

function(gp_resolve_item_override context item exepath dirs resolved_item_var resolved_var)
    get_filename_component(_context_name ${context} NAME)
    get_filename_component(_context_dir ${context} DIRECTORY)
    get_filename_component(_item_name ${item} NAME)
    get_filename_component(_item_base_name ${item} NAME_WE)
    get_filename_component(_item_dir ${item} DIRECTORY)
    #Determine if this search is in the context of the main fixup-target or is itself a dependency
    if(${_context_name} STREQUAL ${target_file_name})
        set(direct_dependency True)
    else()
        set(direct_dependency False)
    endif()

#     message(STATUS "Resolving context_name:${_context_name} context_dir:${_context_dir} item_name:${_item_name} item_dir:${_item_dir} direct_dependency?:${direct_dependency}")
#     message(STATUS "    resolved?:${${resolved_var}} resolved item:${${resolved_item_var}}")
    set(msg_hdr "[${_context_name}] --> ${_item_name}")

    #check if dep_base_name is in provided_libs
    if(provided_libs)
        set(check_name ${_item_base_name})
        if(target_os STREQUAL WIN32) #Window check is case-insensitive
            string(TOLOWER ${check_name} check_name)
        endif()
        if(${check_name} IN_LIST provided_libs)
            message(STATUS "  ... ${msg_hdr}: Vendor provided library name.")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} /provided/${_item_name} PARENT_SCOPE)
            return()
        endif()
        unset(check_name)
    endif()

    #check if target is in vendor provided_lib_dirs.
    # indirect dependencies on WIN32 will have this check come later since they may not be able to find thier dependencies in the
    # vendor-provided libraries.
    if(provided_lib_dirs AND ((NOT target_os STREQUAL WIN32) OR direct_dependency))
        find_file(fitem ${_item_name} PATHS ${provided_lib_dirs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH) #Find in vendor provided_libs
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: In vendor provided lib dir: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #check if target is in lib_copy_dest (COPY_DESTINATION) already - Do not copy
    find_file(fitem ${_item_name} PATHS ${lib_copy_dest} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
    if(fitem)
        message(STATUS "  ... ${msg_hdr}: Exists at lib copy dest: ${lib_copy_dest}")
        set(${resolved_var} True PARENT_SCOPE)
        set(${resolved_item_var} ${lib_copy_dest}/${_item_name} PARENT_SCOPE)
        unset(fitem CACHE)
        return()
    endif()

    #RPATHS [UNIX only]
    if(rpaths AND target_os STREQUAL UNIX)
        find_file(fitem ${_item_name} PATHS ${rpaths} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: Exists on rpath at: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #install_prefix
    find_file(fitem ${_item_name} PATHS ${install_prefix} PATH_SUFFIXES ${default_library_search_suffixs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
    if(fitem)
        get_filename_component(resolved_dir ${fitem} DIRECTORY)
        message(STATUS "  ... ${msg_hdr}: Exists under install prefix at: ${resolved_dir}")
        set(${resolved_var} True PARENT_SCOPE)
        set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
        unset(fitem CACHE)
        return()
    endif()

    #staging_prefix
    if(staging_prefix)
        find_file(fitem ${_item_name} PATHS ${staging_prefix} PATH_SUFFIXES ${default_library_search_suffixs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: Exists under staging prefix at: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #sysroot
    if(sysroot)
        find_file(fitem ${_item_name} PATHS ${sysroot} PATH_SUFFIXES ${default_library_search_suffixs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: Exists under sysroot at: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #SEARCH_LIB_DIRS
    if(search_lib_dirs)
        find_file(fitem ${_item_name} PATHS ${search_lib_dirs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: Exists under fixup_dependencies SEARCH_LIB_DIRS at: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #check in CMAKE_FIND_ROOT_PATH - copy
    if(crosscompiling)
        find_file(fitem ${_item_name} PATHS ${CMAKE_FIND_ROOT_PATH} PATH_SUFFIXES ${default_library_search_suffixs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ... ${msg_hdr}: Exists under CMAKE_FIND_ROOT_PATH: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #Final check for provided libs on WIN32 for indirect dependencies that were skipped earlier
    if(provided_lib_dirs AND target_os STREQUAL WIN32 AND NOT direct_dependency)
        find_file(fitem ${_item_name} PATHS ${provided_lib_dirs} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH) #Find in vendor provided_libs
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            message(STATUS "  ~~~ ${msg_hdr}: Indirect dependency only found In vendor provided lib dir: ${resolved_dir}")
            set(${resolved_var} True PARENT_SCOPE)
            set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
            unset(fitem CACHE)
            return()
        endif()
    endif()

    #check in host system
    find_file(fitem ${_item_name} PATH_SUFFIXES ${default_library_search_suffixs} NO_CMAKE_FIND_ROOT_PATH)
    if(fitem)
        get_filename_component(resolved_dir ${fitem} DIRECTORY)
        if(crosscompiling)
            if(@FIXUP_COPY_SYSTEM_LIBS@)
                message(FATAL_ERROR "  XXX ${msg_hdr}:  Exists under build system dirs at: ${resolved_dir}. COPY_SYSTEM_LIBS is set, so we should not be linking to the system libraries. ")
            else()
                message(STATUS "  ??? ${msg_hdr}: Exists under build system dirs at: ${resolved_dir}.  Probably this is not correct.")
            endif()
        else()
            message(STATUS "  ... ${msg_hdr}: Exists under system dir at: ${resolved_dir}.")
        endif()
        set(${resolved_var} True PARENT_SCOPE)
        set(${resolved_item_var} ${resolved_dir}/${_item_name} PARENT_SCOPE)
        unset(fitem CACHE)
        return()
    endif()

    message(FATAL_ERROR " XXX ${msg_hdr}: Unable to resolve dependency.")
endfunction()

#This function controls how get_prerequisites recurses.  If a library is marked as type: system, the recursion will stop
#We use this to prevent recursion into directories which are assumed to already be in an consistently linked state.
function(gp_resolved_file_type_override resolved_file type)
    get_filename_component(resolved_name ${item} NAME)
    get_filename_component(resolved_base_name ${item} NAME_WE)
    get_filename_component(resolved_dir ${item} DIRECTORY)
    if(resolved_dir)
        get_filename_component(resolved_dir ${resolved_dir} ABSOLUTE)
    endif()
    message(STATUS ">>> Resolving type: ${resolved_name} dir: ${resolved_dir}")

    #provided_libs
    #check if dep_base_name is in provided_libs
    if(provided_libs)
        set(check_name ${resolved_base_name})
        if(target_os STREQUAL WIN32) #Window check is case-insensitive
            string(TOLOWER ${check_name} check_name)
        endif()
        if(${check_name} IN_LIST provided_libs)
            message(STATUS "  *** Resolved type of ${resolved_name} as system. Found in provided_libs")
            set(${type} system PARENT_SCOPE) #Stop recursing
            return()
        endif()
        unset(check_name)
    endif()

    if(resolved_dir STREQUAL "/lib" OR NOT IS_ABSOLUTE resolved_dir)
        #This was found by system ldd at /lib because we must have /lib as first path on LD_LIBRARY_PATH in order for it to work itself.
        #therefore any dep found at "/lib" may have circumvented the normal search order.
        if(target STREQUAL @FIXUP_TARGET@)
            find_file(fitem ${resolved_name} PATHS ${direct_search_path} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        else()
            find_file(fitem ${resolved_name} PATHS ${indirect_search_path} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        endif()
        if(fitem)
            get_filename_component(resolved_dir ${fitem} DIRECTORY)
            unset(fitem)
            unset(fitem CACHE)
        else()
            message(FATAL_ERROR "  XXX Unable to find dependency: ${resolved_name}")
        endif()
    endif()

    if(provided_lib_dirs AND resolved_dir IN_LIST provided_lib_dirs)
        message(STATUS "  *** Resolved type of ${resolved_name} as system. Found in provided_lib_dir at: ${resolved_dir}")
        set(${type} system PARENT_SCOPE) #Stop recursing
        return()
    endif()
    set(${type} other PARENT_SCOPE) #Default: Keep recursing
    if(target_os STREQUAL UNIX AND NOT FIXUP_COPY_SYSTEM_LIBS)
        #determine if this is a system library and can stop recursion
        if(resolved_dir STREQUAL lib_copy_dest OR
           (rpaths AND resolved_dir IN_LIST rpaths) OR
           resolved_dir MATCHES "^${install_prefix}" OR
           (staging_prefix AND resolved_dir MATCHES "^${staging_prefix}") OR
           (search_lib_dirs AND resolved_dir IN_LIST search_lib_dirs))
            message(STATUS "  --- Resolved type of ${resolved_name}: At: ${resolved_dir} as normal library.  Recursing.")
            return()
        elseif()
            message(STATUS "  --- Resolved type of ${resolved_name}: At: ${resolved_dir} as system library.")
            set(${type} system PARENT_SCOPE) #Stop recursing
            return()
        endif()
    endif()
    message(STATUS "  --- Resolved type of ${resolved_name}: At: ${resolved_dir} as normal library.  Recursing.")
endfunction()

#Assemble a list of search directories that
set(lib_search_path ${lib_copy_dest})
foreach(suffix IN LISTS default_library_search_suffixs)
    list(APPEND lib_search_path ${install_prefix}/${suffix})
endforeach()
if(staging_prefix)
    foreach(suffix IN LISTS default_library_search_suffixs)
        list(APPEND lib_search_path ${staging_prefix}/${suffix})
    endforeach()
endif()
if(crosscompiling AND find_root_path)
    foreach(path IN LISTS find_root_path)
        foreach(suffix IN LISTS default_library_search_suffixs)
            list(APPEND lib_search_path ${path}/${suffix})
        endforeach()
    endforeach()
endif()
if(sysroot)
    foreach(suffix IN LISTS default_library_search_suffixs)
        list(APPEND lib_search_path ${sysroot}/${suffix})
    endforeach()
endif()
if(search_lib_dirs)
    list(APPEND lib_search_path ${search_lib_dirs})
endif()

set(direct_search_path ${provided_lib_dirs} ${lib_search_path})
set(indirect_search_path ${lib_search_path} ${provided_lib_dirs})

set(old_ld_env "$ENV{LD_LIBRARY_PATH}")
set(ENV{LD_LIBRARY_PATH} "")

unset(deps)
#Add /lib to search path otherwise ldd will not work correctly
get_prerequisites(${target_install_file} deps ${gp_exclude_system_libs} ${gp_recurse} "" "/lib;${direct_search_path}" "")
set(ENV{LD_LIBRARY_PATH} "${old_ld_env}")
message(STATUS "Fixup Target: ${target_install_file}")
message(STATUS "get_prerequisites deps: ")
foreach(dep IN LISTS deps)
    message(STATUS "   * ${dep}")
endforeach()
#Helper function to also copy to build tree if BUILD_TREE_EXPORT is specified.
macro(do_build_tree_export)
    if(@FIXUP_BUILD_TREE_EXPORT@ AND NOT EXISTS ${target_build_dir}/${dep_name})
        message(STATUS "  &&& ${dep_name}: {BUILD_TREE_EXPORT} Copying to build tree: ${target_build_dir}")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${target_build_dir})
        message(STATUS "  &&& Copying:  ${dep_dir}/${dep_name} --> ${target_build_dir}")
    endif()
endmacro()

foreach(dep IN LISTS deps)
    get_filename_component(dep_name ${dep} NAME)
    get_filename_component(dep_dir ${dep} DIRECTORY)
    message(STATUS "dep_name:${dep_name} dep_dir:${dep_dir}")

    #provided_libs - Do not copy
    #should have been marked in dummy dir /system
    if(provided_libs AND dep_dir STREQUAL "/system")
        message(STATUS "  *** ${dep_name}: Vendor provided library name.")
        continue()
    endif()

    if(dep_dir STREQUAL "/lib" OR NOT IS_ABSOLUTE dep_dir)
        #This was found by system ldd at /lib because we must have /lib as first path on LD_LIBRARY_PATH in order for it to work itself.
        #therefore any dep found at "/lib" may have circumvented the normal search order.
        find_file(fitem ${dep_name} PATHS ${ldd_search_path} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
        if(fitem)
            get_filename_component(dep_dir ${fitem} DIRECTORY)
            unset(fitem)
            unset(fitem CACHE)
        else()
            message(STATUS "  *** Unable to find dependency: ${dep_name} which was auto-resovled to /lib in ldd_search_path.  Maybe this library only exists on the build system?")
        endif()
    endif()

    #provided_lib_dirs - Do not copy
    #For WIN32 indirect targets depds only get resolved to provided_lib_dirs if not found elsewhere first.
    if(provided_lib_dirs AND dep_dir IN_LIST provided_lib_dirs)
        message(STATUS "  *** ${dep_name}: In vendor provided lib dir: ${dep_dir}")
        continue()
    endif()

    #lib_copy_dest (COPY_DESTINATION) - Do not copy
    if(dep_dir STREQUAL lib_copy_dest)
        message(STATUS "  --- ${dep_name}: Already exists at fixup lib copy destination: ${dep_dir}")
        do_build_tree_export() #Copy to build tree if necessary
        continue()
    endif()

    #rpaths - Do not copy [UNIX only]
    if(rpaths AND target_os STREQUAL UNIX AND dep_dir IN_LIST rpaths)
        message(STATUS "  --- ${dep_name}: Already exists on rpath at: ${dep_dir}")
        do_build_tree_export() #Copy to build tree if necessary
        continue()
    endif()

    #install_prefix - Copy for WIN32
    if(dep_dir MATCHES "^${install_prefix}")
        if(target_os STREQUAL UNIX)
            message(STATUS "  --- ${dep_name}: Exists under install_prefix at: ${dep_dir}.")
        elseif(target_os STREQUAL WIN32)
            message(STATUS "  +++ ${dep_name}: Exists under install_prefix at: ${dep_dir}.")
            execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${lib_copy_dest})
            message(STATUS "  +++ Copying:  ${dep_dir}/${dep_name} --> ${lib_copy_dest}")
        endif()
        do_build_tree_export()
        continue()
    endif()

    #staging_prefix - Copy for WIN32 - Condiered availible viar LD_LIBRARY_PATH on linux
    if(staging_prefix AND dep_dir MATCHES "^${staging_prefix}")
        if(target_os STREQUAL UNIX)
            message(STATUS "  --- ${dep_name}: Exists under staging_prefix at: ${dep_dir}.")
        elseif(target_os STREQUAL WIN32)
            message(STATUS "  +++ ${dep_name}: Exists under staging_prefix at: ${dep_dir}.")
            execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${lib_copy_dest})
            message(STATUS "  +++ Copying:  ${dep_dir}/${dep_name} --> ${lib_copy_dest}")
        endif()
        do_build_tree_export()
        continue()
    endif()

    #CMAKE_FIND_ROOT_PATH - these are considered system libraries on linux and will only be copied if COPY_SYSTEM_LIBS is set.
    if(crosscompiling)
        set(_found)
        foreach(root IN LISTS find_root_path)
            if(dep_dir MATCHES "^${root}")
                if(target_os STREQUAL UNIX AND NOT @FIXUP_COPY_SYSTEM_LIBS@)
                    message(STATUS "  --- ${dep_name}: Exists under CMAKE_FIND_ROOT_PATH root:${root} in dir: ${dep_dir}.")
                else()
                    message(STATUS "  +++ ${dep_name}: Exists under CMAKE_FIND_ROOT_PATH root:${root} in dir: ${dep_dir}.")
                    execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${lib_copy_dest})
                    message(STATUS "  +++ Copying:  ${dep_dir}/${dep_name} --> ${lib_copy_dest}")
                    do_build_tree_export()
                endif()
                set(_found True)
                break()
            endif()
        endforeach()
        if(_found)
            unset(_found)
            continue()
        else()
            unset(_found)
        endif()
    endif()

    #sysroot - Copy - these are considered system libraries on linux and will only be copied if COPY_SYSTEM_LIBS is set.
    if(sysroot AND dep_dir MATCHES "^${sysroot}")
        if(target_os STREQUAL UNIX AND NOT @FIXUP_COPY_SYSTEM_LIBS@)
            message(STATUS "  --- ${dep_name}: Exists under sysroot at: ${dep_dir}.")
        else()
            message(STATUS "  +++ ${dep_name}: Exists under sysroot at: ${dep_dir}.")
            execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${lib_copy_dest})
            message(STATUS "  +++ Copying: ${dep_dir}/${dep_name} --> ${lib_copy_dest}")
            do_build_tree_export()
        endif()
        continue()
    endif()

    #FIXUP_SEARCH_LIB_DIRS - copy - these are never consideted system-libraries
    if(search_lib_dirs AND dep_dir IN_LIST search_lib_dirs)
        message(STATUS "  +++ ${dep_name}: Exists under SEARCH_LIB_DIRS at: ${dep_dir}.")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy ${dep_dir}/${dep_name} ${lib_copy_dest})
        message(STATUS "  +++ Copying:  ${dep_dir}/${dep_name} --> ${lib_copy_dest}")
        do_build_tree_export()
        continue()
    endif()

    #host system
    set(_found)
    foreach(suffix IN LISTS default_library_search_suffixs)
        if(dep_dir MATCHES "$/${suffix}")
            if(crosscompiling)
                if(target_os MATCHES WIN32 OR @FIXUP_COPY_SYSTEM_LIBS@)
                    message(FATAL_ERROR "  XXX ${dep_name}: Exists under build system dirs at: ${dep_dir}. This should not happen when fixing-up crosscompiled packages for windows or when FIXUP_COPY_SYSTEM_LIBS is set. ")
                else()
                    message(STATUS "  ??? ${dep_name}: Exists under build system dirs at: ${dep_dir}.  Probably this is not correct.  FIXUP_COPY_SYSTEM_LIBS not set, so ignoring possible error. ")
                endif()
            else()
                message(STATUS "  --- ${dep_name}: Exists under system dir at: ${dep_dir}.")
            endif()
            set(_found True)
            break()
        endif()
    endforeach()
    if(_found)
        unset(_found)
        continue()
    else()
        unset(_found)
    endif()

    message(STATUS " ??? ${dep_name}: How did get_prerequisites find this at: ${dep_dir}")
endforeach()

